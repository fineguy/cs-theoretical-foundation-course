\input{../base.tex}
\graphicspath{ {imgs/} }

\begin{document}

%==================================================
\mynonumbersection{ТЕОРИЯ АВТОМАТОВ}

%==================================================
\mysection{Введение в теорию конечных автоматов}

%========================================
\mysubsection{Модели вычислений}

Большая часть из нас думает о ``компьютерах'' как о ноутбуках, десктопах и, возможно, суперкомпьютерах. В реальности же вокруг нас намного больше небольших ``компьютеров'', которые занимаются вычислениями: часы в микроволновке, сотовые телефоны, кассовые аппараты. О каждом из этих устройств можно думать как о реакционной системе -- так как каждая из них реагирует на сигналы или входы из внешнего мира. \\

В изучении такого большого класса систем, очень полезно иметь какую-нибудь простую модель вычислений, которая абстрагируется от каких-то незначимых деталей программирования или ``реальной жизни''. Это позволяет нам сфокусироваться на ``вычислительной мощности'' конкретной модели вычислений -- что возможно вычислить в данной модели вычислений. Это также позволяет нам сфокусироваться на ``репрезентативной мощности'' конкретной модели вычислений.

%========================================
\mysubsection{Главная идея}

Главное соображение о реакционных системах в том, что ответ на конкретный стимул (сигнал или часть входа) не всегда одинаковый. Например, в случае кассового аппарата он не выдаст чек при нажатии на кнопку, если товар ещё не был оплачен. Таким образом ответ при нажатии на кнопку зависит от предыдущей истории использований системы. \\

Модель конечного автомата ограничивает количество различных ответов на определенные стимулы конечным числом, которые зафиксированы в описании автомата. Это наибольшее различие между конечными автоматами и другими моделями вычислений. По существу в конечном автомате мы можем строить только автоматы, которые имеют конечное количество состояний. Единственное, что может сделать стимул это, возможно, породить какой-то ответ от автомата и изменить его состояние в какое-то новое. \\

При дизайне конечного автомата для конкретной задачи обычно вход для автомата представляет собой последовательность стимулов. Мы будем использовать терминологию ``алфавита'' $\Sigma$, чьи символы соответствуют определенному стимулу, который может быть послан в автомат. Тогда наш вход будет состоять из последовательности символов из этого алфавита, где последовательность обычно называются ``строкой'' над алфавитом $\Sigma$.

%========================================
\mysubsection{Детали}

Мы описываем конечный автомат следующими определениями: \\

\begin{enumerate}
  \item Описание стимула для машины. Оно определяется через конечный входной алфавит, состоящий из различных символов. Входной алфавит обычно обозначается как $\Sigma$.
  \item Описание ответов, которые может выдавать автомат. Оно определяется через конечный выходной алфавит. Выходной алфавит обычно обозначается как $\Lambda$.
  \item Мы описываем автомат в виде диаграммы, состоящей из кружков, которые обозначают различные состояния автомата. Множество состояний конечного автомата обычно обозначается как $Q$.
  \item Часто есть фиксированное начальное состояние автомата. На диаграмме это состояние помечено стрелкой, которая указывает на начальный кружок, но не соединено ни с каким другим состоянием.
  \item Вычислительное поведение автомата описывается переходами, которые являются стрелками, идущими из одного состояния в другое. В случае, если автомат порождает выходы, то каждый переход можно обозначить парой символов $a/b$, где $a$ берётся из $\Sigma$ и $b$ из $\Lambda$. Идея в том, что получив на вход символ $a$, то автомат перейдёт из текущего состояния в состояние $b$. В случае, если автомат не порождает выходы, то каждый переход можно обозначить просто символом из $\Sigma$.
\end{enumerate}

%==============================
\mysubsubsection{Поведение}

Определим след конечного автомата $M$: \\

\begin{enumerate}
  \item Конечная последовательность чередующихся состояний и переходов с начальным и конечными состояними: $s_0, i_1/0_1, s_1, \ldots, s_{n-1}, i_n/o_n, s_n$
  \item Первое состояние $s_o$ это начальное состояние $M$.
  \item Для каждой тройки $s_{j-1}, i_j/o_j, s_j$ (состояние, пара входного и выходного символа, состояние), появляющейся в последовательности, в автомате $M$ должен быть переход из состояния $s_{j-1}$ в $s_j$, обозначенное $i_j/o_j$.
\end{enumerate}

%==============================
\mysubsubsection{Пример}

\myimage{}{0.8}{Пример конечного автомата}{example}

Конечный автомат на рисунке 1 принимает последовательности нулей и единиц, в которых количество нулей никогда не превосходит количество единиц более чем на 1, и наоборот. В данном случае последовательность $0101101$ допустима, так как соответствующий след $B, 0, A, 1, B, 0, A, 1, B, 1, C, 0, B, 1, C$ 
имеет последним состоянием конечное состояние $C$. 

Напротив, последовательность $0101001$ не допустима, так как соответствующий след $B, 0, A, 1, B, 0, A, 1, B, 0, A, 0, D, 1, D$ имеет последним состоянием $D$, которое не является конечным.

%==============================
\mysubsubsection{Детерминированность}

В обсуждении мы ни разу не говорил о том, что из одного состояния можно перейти только в одно состояние. Если это так, то конечный автомат называется ``детерминированным''. Автоматы, в которых из одного состояния можно перейти в несколько, называются ``недетерминированными''.

%==================================================
\mysection{Детерминированные конечные автоматы}

%========================================
\mysubsection{Определение}

Алфавит $\Sigma$ это некоторый набор конечного числа различных символов. Когда мы говорим об алфавите, мы обычно заинтересованы в строках над этим алфавитом. Строка над $\Sigma$ это просто последовательность любого количества символов, взятых из $\Sigma$. Мы обозначаем $\Sigma^*$ множество всех строк над $\Sigma$. Для любого алфавита обязательно есть пустая строка, которые обозначают $\epsilon$. Для любого алфавита $\Sigma$ язык над $\Sigma^*$ это подмножество $L \subset \Sigma^*$.

\label{def-dfsm}\mydefinition{
Детерминированный конечный автомат это автомат $M$, определенный как набор

\myequation{M = (Q, \Sigma, s_0, F, \Delta)}, состоящий из: \\

\begin{enumerate}
  \item конечного множества состояний $Q$ 
  \item конечного алфавита $\Sigma$
  \item выделенного начального состояния $s_o \in Q$
  \item множества $F \subseteq Q$ конечных состояний и
  \item функции переходов $\Delta : Q \times \Sigma \rightarrow Q$.
\end{enumerate}
}

\mydefinition{
Допустимый язык $L$ конечного автомата \\
$M = (Q, \Sigma, s_0, F, \Delta)$ это множество строк $x \in \Sigma^*$ такое, что: \\

\begin{itemize}
  \item есть след $x$ в автомате $M$;
  \item след заканчивается в конечном состоянии автомата $M$.
\end{itemize}
}

Заметим, что для любого детерминированного конечного автомата, чей набор переходов является функцией, всегда выполняется первое условие (существует след для любой строки $x \in \Sigma^*$). Таким образом для любого $x \in \Sigma^*$, $x$ не допустима тогда и только тогда. когда последнее состояние его следа это не конечное состояние (последнее состояние не находится в $F$).

\mytheorem{
Каждый детерминированный конечный автомат эквивалентен детерминированному конечному автомате, который удовлетворяет условиям из определения \ref{def-dfsm}. 
}

\myproof{
Пусть $M$ это детерминированный конечный автомат, чей набор переходов не является строго определенной функцией. Тогда может существовать некоторая строка $x \in \Sigma^*$, которая не допустима автоматом, потому что не существует следа для этой строки. Добавим в автомат $M$ новое состояние $Q$, которое мы будем называть ``удаленным'' состоянием. Удаленное состояние не является конечным состоянием. Теперь для каждого состояния $q$ и каждого символа $a$ такого, что нет перехода из $q$ помеченного $a$, мы добавим переход, используя удаленное состояние как результат этого перехода. Таким образом мы направим все строки, у которых нет следа в автомате $M$ в это новое удаленное состояние, которое не является конечным. Мы также добавим переход из удаленного состояние в него же по всем символам из алфавита $\Sigma$. Это обеспечит нам то, что функция переходов является строгой на расширенном наборе состояний, и что единожды направленная в удаленное состояние строка будет оставаться в нём. Таким образом каждая строка, у которая нет следа в автомате $M$ теперь имеет след в расширенном конечном детерминированном автомате, и каждая такая строка будет недопустимой для нового автомата. Тем самым язык нового автомата идентичен $L(M)$.
}

%========================================
\mysubsection{Детерминированный конечный автомат для распознавания нечетных чисел}

Теперь рассмотрим задачу создания детерминированного конечного автомата для распознавания нечетных натуральных чисел. 

\myimage{}{0.6}{Автомат для распознавания нечетный натуральных чисел}{odd}

Заметим, что автомат на рисунке 2 детерминированный. В нём нет множественных переходов, и все переходы исходящие из одного состояния имеют разные символы.

%==================================================
\mysection{Недетерминированные конечные автоматы}

%========================================
\mysubsection{Определение}

Главное отличие между недетерминированными и детерминированными конечными автоматами в том, что входные строки могут иметь больше одного следа.

Концепт недетерминированности даёт нам больше гибкости, когда мы моделируем реакционные системы: мы можем использовать его, чтобы помочь нам описать системы, чьё поведение мы не можем полностью предсказать. За такую гибкость приходится платить -- у нас больше нет приятного свойства, что каждая входная строка имеет в точности один вычислительный путь (след), который можно предсказать из определения конечного автомата. Это значит, например, что реализация недетерминированного конечного автомата на языках программирования не такая прямолинейная задача. 

Однако главный интерес в недетерминированных конечных автоматах это изучение формальных языков, для которых они очень ценны. 

\label{def-ndfsm}\mydefinition{
Недетерминированный конечный автомат это автомат $M$, определенный как набор

\myequation{M = (Q, \Sigma, s_0, F, \Delta)}, состоящий из: \\

\begin{enumerate}
  \item конечного множества состояний $Q$ 
  \item конечного алфавита $\Sigma$
  \item выделенного начального состояния $s_o \in Q$
  \item множества $F \subseteq Q$ конечных состояний и
  \item описания $\Delta$ всех возможных переходов. Формально $\Delta$ это функция вида $\Delta : Q \times (\Sigma \cup \{ \epsilon \}) \rightarrow P(Q)$, где $P(Q)$ -- множество всех подмножеств множества $Q$.
\end{enumerate}
}

%==============================
\mysubsubsection{Пример}

\myimage{}{0.6}{Автомат, принимающий строки, оканчивающиеся на $aba$}{nfsm}

Рисунок 3 демонстрирует недетерминированный конечный автомат $M$, который принимает строки над алфавитом $\Sigma=\{ a, b \}$, которые оканчиваются на $aba$. Автомат $M$ имеет формальное определение:

\myequation{M = (\{ 0, 1, 2, 3 \}, \{ a, b \}, 0, \{ 3 \}, \Delta)}, 

Где описание $\Delta$ всех возможных переходов задаётся таблицей:

\begin{center}
\begin{tabular}{c | c c}
$\Delta$ & a & b \\
\hline
0 & \{ 0, 1 \} & \{ 0 \} \\
1 & $\O$ & \{ 2 \} \\
2 & \{ 3 \} & $\O$ \\
3 & $\O$ & $\O$ \\
\end{tabular}
\end{center}
\

Когда мы видим в таблице символ пустого множества $\O$, это означает, что для данного состояния и символа не существует перехода ни в одно состояние. Таким образом не может быть следа, проходящего через данное состояние и считывающего данный символ. 

Теперь заметим, что любая строка из $a$ и $b$ будет принята автоматом, если она проходит через состояния 1, 2 и 3 в самом конце своего следа. Это возможно тогда и только тогда, когда строка заканчивается на $aba$. Таким образом допустимый язык для автомата на рисунке 3:

\myequation{L(M) = \{ xaba | x \in \{a, b \}^* \}}

%\myframe{Хорошая мера ``информации'' должна учитывать вероятности возможных исходов.}

%\myproof{
%Так как обусловленность уменьшает энтропию, то:
%\myequation{ I(X;Y) = H(Y) - H(Y|X) \geq H(Y) - H(Y) = 0}
%причем равенство возможно только когда $H(Y|X) = H(Y)$. Чтобы доказать правую часть, воспользуемся неотрицательностью энтропии:
%\myequation[\Rightarrow I(X;Y) \leq \min \{ H(X), H(Y) \}]{
%  I(X;Y) = H(X) - H(X|Y) \leq H(X) \\
%  I(X;Y) = H(Y) - H(Y|X) \leq H(Y)
%}
%причем равенство возможно только когда $H(X|Y)=0$, либо $H(Y|X)=0$, т.е. либо $Y$ задаёт $X$, либо наоборот.
%}

%Заметим, что совместная информация случайной величины с самой собой будет в точности её энтропия:

%\myequation{ I(X; X) = H(X) - H(X|X) = H(X) }

\end{document}

